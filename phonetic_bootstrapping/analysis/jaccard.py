__author__ = 'GCassani'

"""Function to compute the Jaccard distance between lexical items and the top active cues in the activation matrix
   estimated with the ndl function given the test lexical item"""

import os
import operator
import numpy as np
from celex.utilities.dictionaries import tokens2ids
from celex.get import get_celex_dictionary
from corpus.encode.words.phonology import get_phonological_form
from corpus.encode.item import encode_item
from phonetic_bootstrapping.analysis.plot import plot_ranks


def get_top_active_cues(weight_matrix, col, n, reversed_cue_ids):

    """
    :param weight_matrix:       a NumPy array, containing numerical values
    :param col:                 an integer specifying which column from the input array needs to be considered
    :param n:                   an integer specifying how many elements (i.e. row indices) from the column vector are
                                considered
    :param reversed_cue_ids:    a dictionary mapping row indices to strings
    :return top_active_cues:    a set of strings, including all the strings from the input dictionary matching the row
                                indices selected from the specified column in the input NumPy array
    """

    top_active_cues_ids = set()
    top_active_cues = set()

    # sort column values in descending order, to get most active cues first
    sorted_col = np.argsort(weight_matrix[:, col])[::-1]

    # consider the n top active cues but keep adding cues if their activation values is the same as the n-th cue:
    # this has the purpose of avoiding that one cue out of many gets selected as the n-th out of other criteria
    for i in range(len(sorted_col)):
        if i < n:
            top_active_cues_ids.add(sorted_col[i])
        else:
            if weight_matrix[sorted_col[i], col] == weight_matrix[sorted_col[i-1], col]:
                top_active_cues_ids.add(sorted_col[i])
            else:
                break

    for identifier in top_active_cues_ids:
        try:
            top_active_cues.add(reversed_cue_ids[identifier])
        except KeyError:
            continue

    return top_active_cues


########################################################################################################################


def jaccard(weight_matrix, row_ids, column_ids, celex_dict, plots_folder, reduced=True,
            stress_marker=False, uniphone=True, diphone=False, triphone=False, syllable=False):

    """
    :param weight_matrix:           a NumPy array
    :param row_ids:                 a dictionary mapping strings to row indices in the weight_matrix
    :param column_ids:              a dictionary mapping strings to column indices in the weight_matrix
    :param celex_dict:              a string specifying the path to the Celex dictionary
    :param plots_folder:            a string indicating the path to a folder, where all the plots and files generated by
                                    the function will be stored. The function checks if the folder already exists, and
                                    if it doesn't the function creates it
    :param reduced:                 a boolean specifying whether reduce phonological form should be always preferred
                                    when available. This parameter depends on how the training corpus was extracted in
                                    the first place: if the corpus was extracted with reduced variants being considered,
                                    setting this parameter to False here does not make any sense.
    :param uniphone:                a boolean indicating whether single phonemes are to be considered while encoding
                                    column identifiers
    :param diphone:                 a boolean indicating whether sequences of two phonemes are to be considered while
                                    encoding column identifiers
    :param triphone:                a boolean indicating whether sequences of three phonemes are to be considered while
                                    encoding column identifiers
    :param syllable:                a boolean indicating whether syllables are to be considered while encoding column
                                    identifiers
    :param stress_marker:           a boolean indicating whether stress markers from the phonological representations of
                                    Celex need to be preserved or can be discarded
    :return jaccard_coefficients:   a dictionary mapping outcome surface forms (strings) to the Jaccard coefficient
                                    computed between the gold-standard and most active cues as estimated from the input
                                    matrix. Gold-standard cues are extracted from the outcome phonological form
                                    according the specified encoding; moreover, a vector of length k (where k is the
                                    number of gold-standard cues) is filled with the top k cues for the outcome being
                                    considered, looking at raw activation values. `The Jaccard coefficient is the
                                    proportion between the intersection of the two vectors and their union, telling how
                                    many cues are shared proportionally to how many unique cues there are. The higher
                                    the number, the higher the overlap and the better the network was able to
                                    discriminate the good cues for an outcome.
    """

    # specify the string that identifies plots generated by this function in their file names
    f_name = 'jaccard'

    # check whether the provided folder path points to an existing folder, and create it if it doesn't already exist
    # then checks that the path ends with a slash, and add one if it doesn't
    if not os.path.isdir(plots_folder):
        os.makedirs(plots_folder)

    celex_dict = get_celex_dictionary(celex_dict, reduced)

    token_indices = tokens2ids(celex_dict)

    jaccard_coefficients = {}
    true_cues = {}
    active_cues = {}
    reversed_cue_ids = dict(zip(row_ids.values(), row_ids.keys()))

    # consider each outcome separately
    for el in column_ids:

        # get the column id of the outcome being considered
        col_idx = column_ids[el]

        # get the phonological form of the outcome from CELEX
        wordform, pos = el.split('|')
        outcome = (wordform, pos, wordform)
        word_phon = get_phonological_form(outcome, celex_dict, token_indices)

        if isinstance(word_phon, str):

            # get the relevant phonological units from the outcome phonological form
            nphones = encode_item(word_phon, stress_marker=stress_marker, uni_phones=uniphone,
                                  di_phones=diphone, tri_phones=triphone, syllable=syllable)

            # get the top active phonological cues from the input association matrix given the outcome being considered
            top_active_cues = get_top_active_cues(weight_matrix, col_idx, len(nphones), reversed_cue_ids)

            # compute the Jaccard coefficient and store correct and predicted cues for every outcome
            set_inters = len(set.intersection(top_active_cues, set(nphones)))
            set_union = len(set.union(top_active_cues, set(nphones)))
            jaccard_coefficients[el] = set_inters / set_union
            true_cues[el] = nphones
            active_cues[el] = top_active_cues

    ranked_path = os.path.join(plots_folder, '.'.join(["_".join([f_name, 'list']), 'txt']))
    sorted_coeffs = sorted(jaccard_coefficients.items(), key=operator.itemgetter(1), reverse=True)

    scatter_path = os.path.join(plots_folder, ".".join(["_".join([f_name, 'scatter']), 'pdf']))
    plot_ranks(sorted_coeffs, output_path=scatter_path, yname='Jaccard coeff',
               xname='Rank', figname='Jaccard coefficient for each outcome')

    # write to file each outcome together with the correct and predicted phonological cues
    for el in sorted_coeffs:
        outcome = el[0]
        jaccard_coeff = el[1]
        true = true_cues[outcome]
        top_active = active_cues[outcome]
        with open(ranked_path, 'a+') as f_name:
            f_name.write("\t".join([outcome, str(jaccard_coeff), str(true), str(top_active)]))
            f_name.write("\n")

    return jaccard_coefficients
